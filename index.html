<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- å…³é”®ï¼šç¦æ­¢ç”¨æˆ·ç¼©æ”¾ï¼Œç¡®ä¿è§¦æ‘¸ä½“éªŒåƒåŸç”Ÿ App -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è‰ºæœ¯å®¶çš„ç©ºé—´ç”»å¸ƒ - å…¨å¹³å°é€‚é…ç‰ˆ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* ç¦æ­¢æ•´ä¸ªé¡µé¢æ»šåŠ¨ */
            background-color: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: #eee;
            -webkit-tap-highlight-color: transparent; /* å»é™¤ç‚¹å‡»é«˜äº® */
        }

        /* 3D å®¹å™¨å…¨å± */
        #three-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background: radial-gradient(circle at center, #2a2a2a 0%, #000 100%);
        }

        /* ç§»åŠ¨ç«¯æ‚¬æµ®å¼€å…³æŒ‰é’® */
        #toggle-ui-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            width: 44px;
            height: 44px;
            font-size: 20px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        /* å·¦ä¾§æ§åˆ¶é¢æ¿å®¹å™¨ */
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€ç©ºç™½åŒºåŸŸ */
            z-index: 10;
            display: flex;
            flex-direction: column;
            padding: 15px;
            box-sizing: border-box;
            overflow-y: auto; /* å…è®¸é¢æ¿å†…éƒ¨æ»šåŠ¨ */
            transition: transform 0.3s ease;
        }

        /* é¢æ¿éšè—çŠ¶æ€ */
        #ui-container.hidden {
            transform: translateX(-120%);
        }

        .panel-group {
            width: 320px;
            max-width: 100%; /* é€‚é…å°å±å¹• */
            pointer-events: auto; /* æ¢å¤äº¤äº’ */
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding-bottom: 20px; /* åº•éƒ¨ç•™ç™½ */
        }

        .panel {
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            transition: border-color 0.3s;
        }

        .panel.edit-mode-active {
            border-color: #ff9f43;
            box-shadow: 0 0 15px rgba(255, 159, 67, 0.3);
        }

        h1 {
            font-size: 16px;
            margin: 0 0 10px 0;
            color: #4facfe;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .status-badge { font-size: 10px; color: #fff; background:#444; padding: 2px 6px; border-radius:4px; }
        .mode-draw { background: #4facfe; }
        .mode-edit { background: #ff9f43; }

        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            font-size: 13px;
            color: #ccc;
        }

        /* æè´¨ç½‘æ ¼ - æ›´å¤§çš„ç‚¹å‡»åŒºåŸŸ */
        .material-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .mat-btn {
            height: 55px;
            border-radius: 10px;
            border: 2px solid transparent;
            cursor: pointer;
            position: relative;
            background-size: cover;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            background: #444;
            color: #fff;
            /* ç¦æ­¢æ–‡å­—é€‰ä¸­ */
            user-select: none; 
        }

        .mat-btn span {
            font-size: 10px;
            margin-top: 2px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            z-index: 2;
        }

        .mat-btn.active { border-color: #fff; transform: scale(0.98); background-color: #555; }
        
        /* æè´¨è§†è§‰æ•ˆæœ */
        .mat-standard { background: linear-gradient(135deg, #7f8fa6, #353b48); }
        .mat-glass { background: linear-gradient(135deg, rgba(164, 219, 255, 0.6), rgba(255,255,255,0.1)); }
        .mat-metal { background: linear-gradient(135deg, #dcdde1 0%, #718093 100%); color: #2f3640; }
        .mat-glossy { background: radial-gradient(circle at 30% 30%, #fff 0%, #e84118 100%); }
        .mat-glow { background: #000; border: 1px solid #4facfe; box-shadow: inset 0 0 10px #4facfe;}
        .mat-frosted { background: linear-gradient(135deg, #bdc3c7, #2c3e50); opacity: 0.8; }

        /* å¤§æŒ‰é’®é€‚åˆè§¦æ‘¸ */
        button.action-btn {
            width: 100%;
            padding: 12px; /* æ›´å¤§çš„ç‚¹å‡»åŒºåŸŸ */
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: #444;
            color: white;
            font-size: 13px;
            margin-top: 5px;
            font-weight: 500;
            touch-action: manipulation; /* ä¼˜åŒ–ç‚¹å‡»å“åº” */
        }
        button.action-btn:active { background: #555; transform: scale(0.98); }
        
        #mode-toggle-btn {
            background: linear-gradient(to right, #4facfe, #00f2fe);
            color: #000;
            font-weight: bold;
            margin-bottom: 15px;
        }
        #mode-toggle-btn.editing {
            background: linear-gradient(to right, #ff9f43, #ff6b6b);
            color: #fff;
        }

        #clear-btn { background: #ff4757; color: white; }
        #export-btn { background: #2ed573; color: #1e272e; }

        input[type="color"] {
            border: none; width: 40px; height: 30px; background: none; padding: 0;
        }

        input[type="range"] {
            width: 60%; height: 6px; border-radius: 3px;
        }
        /* åŠ å¤§æ»‘å—ä¾¿äºæ‰‹æŒ‡æ‹–åŠ¨ */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        /* ç”»å¸ƒå®¹å™¨å“åº”å¼é€‚é… */
        #canvas-wrapper {
            width: 100%;
            max-width: 290px;
            aspect-ratio: 1 / 1; /* ä¿æŒæ­£æ–¹å½¢ */
            background: #000;
            border: 1px solid #444;
            position: relative;
            cursor: crosshair;
            margin: 0 auto;
            touch-action: none; /* å…³é”®ï¼šç¦æ­¢ç”»å¸ƒä¸Šçš„æµè§ˆå™¨é»˜è®¤æ‰‹åŠ¿ï¼ˆå¦‚æ»šåŠ¨ï¼‰ */
        }
        
        canvas { 
            display: block; 
            width: 100%;
            height: 100%;
        }
        
        .axis-label {
            position: absolute; font-size: 10px; color: #666; pointer-events: none;
        }
        .label-y { top: 5px; left: 5px; }
        .label-x { bottom: 5px; right: 5px; }
        .label-center { bottom: 5px; left: 5px; color: #4facfe; font-weight: bold;}

    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <button id="toggle-ui-btn">ğŸ‘ï¸</button>

    <div id="three-container"></div>

    <div id="ui-container">
        <div class="panel-group">
            
            <!-- æè´¨ä¸æ§åˆ¶ -->
            <div class="panel" id="main-panel">
                <h1>
                    æè´¨å·¥åŠ <span id="status-text" class="status-badge mode-draw">ç»˜ç”»æ¨¡å¼</span>
                </h1>

                <button class="action-btn" id="mode-toggle-btn">ğŸ‘† åˆ‡æ¢ï¼šç‚¹å‡»é€‰æ‹©æ¨¡å¼</button>
                
                <div class="control-row" style="margin-top: 10px; margin-bottom: 5px;">
                    <span id="control-title">ç”»ç¬”æè´¨é¢„è®¾:</span>
                </div>
                
                <div class="material-grid">
                    <div class="mat-btn mat-standard active" data-type="standard"><span>âšª é»˜è®¤</span></div>
                    <div class="mat-btn mat-glass" data-type="glass"><span>ğŸ· ç»ç’ƒ</span></div>
                    <div class="mat-btn mat-metal" data-type="metal"><span>âš™ï¸ é‡‘å±</span></div>
                    <div class="mat-btn mat-glossy" data-type="glossy"><span>ğŸ¬ é™¶ç“·</span></div>
                    <div class="mat-btn mat-glow" data-type="glow"><span>ğŸ’¡ éœ“è™¹</span></div>
                    <div class="mat-btn mat-frosted" data-type="frosted"><span>â„ï¸ ç£¨ç ‚</span></div>
                </div>

                <div class="control-row">
                    <span>ğŸ¨ é¢œè‰²</span>
                    <input type="color" id="stroke-color" value="#ffffff">
                </div>
                
                <div class="control-row">
                    <span>ğŸ’§ é€æ˜åº¦ (<span id="opacity-val">1.0</span>)</span>
                    <input type="range" id="opacity-slider" min="0" max="1" step="0.05" value="1">
                </div>

                <div class="control-row" id="smooth-row">
                    <span>ğŸ–Šï¸ è‡ªåŠ¨å¹³æ»‘</span>
                    <input type="checkbox" id="auto-smooth" checked style="width:20px; height:20px;">
                </div>
                
                <div class="control-row" id="guide-row">
                    <span>ğŸ“ è¾…åŠ©è½®å»“</span>
                    <select id="guide-mode" style="background:#444; color:#fff; border:1px solid #555; padding:5px; border-radius:4px; font-size:12px;">
                        <option value="none">æ— </option>
                        <option value="cup">é…’æ¯</option>
                        <option value="sphere">çƒä½“</option>
                        <option value="vase">èŠ±ç“¶</option>
                    </select>
                </div>
            </div>

            <!-- æ“ä½œæŒ‰é’® -->
            <div class="panel" style="padding: 10px; display:flex; gap:8px;">
                <button class="action-btn" id="undo-btn">â†© æ’¤é”€</button>
                <button class="action-btn" id="clear-btn">ğŸ—‘ï¸ æ¸…ç©º</button>
                <button class="action-btn" id="export-btn">ğŸ’¾ å¯¼å‡º</button>
            </div>

            <!-- ç”»å¸ƒåŒºåŸŸ -->
            <div class="panel" id="canvas-panel" style="padding: 10px;">
                <div id="canvas-wrapper">
                    <!-- å†…éƒ¨åˆ†è¾¨ç‡ 580x580 (290*2) é€‚é…é«˜æ¸…å± -->
                    <canvas id="drawing-canvas" width="580" height="580"></canvas>
                    <div class="axis-label label-y">Top</div>
                    <div class="axis-label label-x">Radius</div>
                    <div class="axis-label label-center">Axis</div>
                </div>
                <div style="text-align:center; font-size:11px; color:#666; margin-top:5px;">
                    åœ¨æ–¹æ¡†å†…å•æŒ‡ç»˜å›¾
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { OBJExporter } from 'three/addons/exporters/OBJExporter.js';

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, objectGroup, controls;
        let drawingCanvas, ctx;
        let isDrawing = false;
        
        // äº¤äº’ç›¸å…³
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let selectedObject = null;
        let selectionBox = null;
        let isEditMode = false;
        let uiVisible = true;
        
        // å­˜å‚¨æ•°æ®
        let strokes = []; 
        let currentStrokePoints = [];
        
        // çŠ¶æ€
        let appState = {
            type: 'standard', 
            color: '#ffffff',
            opacity: 1.0
        };
        
        // ç”»å¸ƒé€»è¾‘åˆ†è¾¨ç‡ï¼ˆå†…éƒ¨åƒç´ ï¼‰
        const CANVAS_RES = 580; 

        initThreeJS();
        initCanvas();
        setupEvents();

        // ----------------------------------------------------------------
        // 1. è§¦æ‘¸ä¸è¾“å…¥å¤„ç† (æ ¸å¿ƒæ›´æ–°)
        // ----------------------------------------------------------------
        
        // ç»Ÿä¸€è·å–åæ ‡å‡½æ•° (å…¼å®¹ Mouse å’Œ Touchï¼Œå¹¶å¤„ç† CSS ç¼©æ”¾)
        function getPos(e) {
            const rect = drawingCanvas.getBoundingClientRect();
            let clientX, clientY;

            // åˆ¤æ–­æ˜¯è§¦æ‘¸è¿˜æ˜¯é¼ æ ‡
            if (e.changedTouches && e.changedTouches.length > 0) {
                clientX = e.changedTouches[0].clientX;
                clientY = e.changedTouches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            // è®¡ç®—ç›¸å¯¹äº Canvas DOM å…ƒç´ çš„åæ ‡
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            // æ˜ å°„åˆ° Canvas å†…éƒ¨åˆ†è¾¨ç‡ (580x580)
            // å› ä¸º CSS width å¯èƒ½æ˜¯ 290px æˆ–æ›´å°ï¼Œæ‰€ä»¥å¿…é¡»æŒ‰æ¯”ä¾‹æ”¾å¤§
            const scaleX = drawingCanvas.width / rect.width;
            const scaleY = drawingCanvas.height / rect.height;

            return { 
                x: x * scaleX, 
                y: y * scaleY 
            };
        }

        function initCanvas() {
            drawingCanvas = document.getElementById('drawing-canvas');
            ctx = drawingCanvas.getContext('2d');
            // åˆå§‹ç»˜åˆ¶
            redraw2D(); 
        }

        // ----------------------------------------------------------------
        // 2. äº¤äº’é€»è¾‘
        // ----------------------------------------------------------------

        function setupEvents() {
            // --- éšè—/æ˜¾ç¤º UI ---
            const toggleBtn = document.getElementById('toggle-ui-btn');
            const uiContainer = document.getElementById('ui-container');
            toggleBtn.addEventListener('click', () => {
                uiVisible = !uiVisible;
                if (uiVisible) {
                    uiContainer.classList.remove('hidden');
                    toggleBtn.style.opacity = '1';
                } else {
                    uiContainer.classList.add('hidden');
                    toggleBtn.style.opacity = '0.5';
                }
            });

            // --- ç»˜ç”»è¾“å…¥ (Mouse + Touch) ---
            const startDraw = (e) => {
                // å¦‚æœæ˜¯ç¼–è¾‘æ¨¡å¼ï¼Œæˆ–è€…æ˜¯å¤šç‚¹è§¦æ§ï¼ˆç¼©æ”¾é¡µé¢ï¼‰ï¼Œåˆ™ä¸ç”»ç”»
                if (isEditMode) return;
                if (e.touches && e.touches.length > 1) return;
                
                // é˜»æ­¢é»˜è®¤äº‹ä»¶ï¼ˆé˜²æ­¢ç”»ç”»æ—¶æ»šåŠ¨é¡µé¢ï¼‰
                if(e.cancelable) e.preventDefault();

                isDrawing = true;
                currentStrokePoints = [];
                currentStrokePoints.push(getPos(e));
                
                // ç»˜ç”»å¼€å§‹æ—¶è‡ªåŠ¨ç¦æ­¢ OrbitControlsï¼Œé˜²æ­¢é•œå¤´ä¹±è½¬
                if (controls) controls.enabled = false;
                
                redraw2D();
            };

            const moveDraw = (e) => {
                if (!isDrawing) return;
                if(e.cancelable) e.preventDefault(); // å…³é”®ï¼šç¦æ­¢æ»šåŠ¨

                const p = getPos(e);
                const lastP = currentStrokePoints[currentStrokePoints.length - 1];
                
                // è·ç¦»æ£€æµ‹ï¼Œé˜²æ­¢ç‚¹è¿‡å¯†
                const dist = Math.hypot(p.x - lastP.x, p.y - lastP.y);
                if (dist > 5) { // é˜ˆå€¼è°ƒé«˜ä¸€ç‚¹é€‚é…é«˜åˆ†å±
                    currentStrokePoints.push(p);
                    redraw2D(); 
                }
            };

            const endDraw = (e) => {
                if (isDrawing) {
                    isDrawing = false;
                    // æ¢å¤ OrbitControls
                    if (controls) controls.enabled = true;

                    if (currentStrokePoints.length > 2) {
                        const isSmooth = document.getElementById('auto-smooth').checked;
                        if (isSmooth) currentStrokePoints = smoothPoints(currentStrokePoints);

                        const config = { ...appState };
                        const strokeData = { points: [...currentStrokePoints], config: config, meshUUID: null };
                        strokes.push(strokeData);
                        
                        update3DScene();
                    }
                    currentStrokePoints = [];
                    redraw2D();
                }
            };

            // é¼ æ ‡äº‹ä»¶
            drawingCanvas.addEventListener('mousedown', startDraw);
            window.addEventListener('mousemove', moveDraw);
            window.addEventListener('mouseup', endDraw);

            // è§¦æ‘¸äº‹ä»¶ (è¢«åŠ¨ç›‘å¬å™¨è®¾ä¸º false ä»¥å…è®¸ preventDefault)
            drawingCanvas.addEventListener('touchstart', startDraw, { passive: false });
            window.addEventListener('touchmove', moveDraw, { passive: false });
            window.addEventListener('touchend', endDraw);
            window.addEventListener('touchcancel', endDraw);

            // --- UI æ§ä»¶é€»è¾‘ (ä¸ä¹‹å‰ç›¸åŒ) ---
            document.getElementById('mode-toggle-btn').addEventListener('click', toggleMode);
            
            document.querySelectorAll('.mat-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    // ç§»é™¤ä¹‹å‰çš„ active
                    document.querySelectorAll('.mat-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    appState.type = btn.dataset.type;
                    if (isEditMode && selectedObject) applyStateToSelectedObject();
                });
            });

            document.getElementById('stroke-color').addEventListener('input', (e) => {
                appState.color = e.target.value;
                if (isEditMode && selectedObject) applyStateToSelectedObject();
            });

            document.getElementById('opacity-slider').addEventListener('input', (e) => {
                appState.opacity = parseFloat(e.target.value);
                document.getElementById('opacity-val').innerText = appState.opacity;
                if (isEditMode && selectedObject) applyStateToSelectedObject();
            });

            // 3D ç‚¹å‡»é€‰æ‹© (PC + Mobile Tap)
            const canvas3D = renderer.domElement;
            // ä½¿ç”¨ pointerup æ¨¡æ‹Ÿç‚¹å‡»ï¼Œé¿å…ä¸ OrbitControls æ‹–æ‹½å†²çª
            // ç®€å•çš„é€»è¾‘ï¼šæŒ‰ä¸‹å’ŒæŠ¬èµ·ä½ç½®å‡ ä¹æ²¡å˜æ‰ç®—ç‚¹å‡»
            let downPos = {x:0, y:0};
            canvas3D.addEventListener('pointerdown', (e) => {
                downPos.x = e.clientX;
                downPos.y = e.clientY;
            });
            canvas3D.addEventListener('pointerup', (e) => {
                const dist = Math.hypot(e.clientX - downPos.x, e.clientY - downPos.y);
                if (dist < 5) on3DClick(e);
            });

            document.getElementById('clear-btn').addEventListener('click', () => {
                strokes = []; 
                selectedObject = null;
                if(selectionBox) scene.remove(selectionBox);
                update3DScene(); 
                redraw2D(); 
            });

            document.getElementById('undo-btn').addEventListener('click', () => {
                strokes.pop(); 
                update3DScene();
                redraw2D();
            });

            document.getElementById('guide-mode').addEventListener('change', () => { redraw2D(); });
            document.getElementById('export-btn').addEventListener('click', exportToOBJ);
        }

        // --- é€»è¾‘å‡½æ•° ---

        function toggleMode() {
            isEditMode = !isEditMode;
            const btn = document.getElementById('mode-toggle-btn');
            const status = document.getElementById('status-text');
            const mainPanel = document.getElementById('main-panel');
            const canvasPanel = document.getElementById('canvas-panel');
            const controlTitle = document.getElementById('control-title');

            if (isEditMode) {
                btn.innerText = "âœï¸ åˆ‡æ¢ä¸ºï¼šç»˜ç”»æ¨¡å¼";
                btn.classList.add('editing');
                status.innerText = "ç‚¹å‡»ç¼–è¾‘";
                status.className = "status-badge mode-edit";
                mainPanel.classList.add('edit-mode-active');
                canvasPanel.style.display = 'none';
                controlTitle.innerText = "ä¿®æ”¹é€‰ä¸­æè´¨:";
            } else {
                btn.innerText = "ğŸ‘† åˆ‡æ¢ä¸ºï¼šç‚¹å‡»é€‰æ‹©æ¨¡å¼";
                btn.classList.remove('editing');
                status.innerText = "ç»˜ç”»æ¨¡å¼";
                status.className = "status-badge mode-draw";
                mainPanel.classList.remove('edit-mode-active');
                canvasPanel.style.display = 'block';
                controlTitle.innerText = "ç”»ç¬”æè´¨é¢„è®¾:";
                deselectObject();
            }
        }

        function applyStateToSelectedObject() {
            if (!selectedObject || !isEditMode) return;
            const newMaterial = createMaterial({
                type: appState.type,
                color: appState.color,
                opacity: appState.opacity
            });
            selectedObject.material = newMaterial;
            
            // åŒæ­¥æ•°æ®
            const strokeIndex = strokes.findIndex(s => s.meshUUID === selectedObject.uuid);
            if (strokeIndex !== -1) {
                strokes[strokeIndex].config = { ...appState };
            }
        }

        function on3DClick(event) {
            if (!isEditMode) return;
            
            // PointerEvent å…¼å®¹é¼ æ ‡å’Œè§¦æ‘¸
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(objectGroup.children, false);

            if (intersects.length > 0) {
                selectObject(intersects[0].object);
            } else {
                deselectObject();
            }
        }

        function selectObject(mesh) {
            if (selectedObject === mesh) return;
            selectedObject = mesh;
            if (selectionBox) scene.remove(selectionBox);
            selectionBox = new THREE.BoxHelper(mesh, 0xff9f43);
            scene.add(selectionBox);

            // æ›´æ–° UI çŠ¶æ€
            const stroke = strokes.find(s => s.meshUUID === mesh.uuid);
            if (stroke) {
                appState = { ...stroke.config };
                
                // æ›´æ–° DOM
                document.querySelectorAll('.mat-btn').forEach(b => {
                    b.classList.remove('active');
                    if(b.dataset.type === appState.type) b.classList.add('active');
                });
                document.getElementById('stroke-color').value = appState.color;
                document.getElementById('opacity-slider').value = appState.opacity;
                document.getElementById('opacity-val').innerText = appState.opacity;
            }
        }

        function deselectObject() {
            selectedObject = null;
            if (selectionBox) {
                scene.remove(selectionBox);
                selectionBox = null;
            }
        }

        function redraw2D() {
            const width = drawingCanvas.width;
            const height = drawingCanvas.height;
            const mode = document.getElementById('guide-mode').value;

            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            drawGuides(mode);

            strokes.forEach(stroke => {
                drawSingleStroke(stroke.points, stroke.config.color, 0.4);
            });

            if (isDrawing && currentStrokePoints.length > 0) {
                drawSingleStroke(currentStrokePoints, appState.color, 1.0);
            }
        }

        function drawGuides(mode) {
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, CANVAS_RES);
            ctx.strokeStyle = '#4facfe'; 
            ctx.lineWidth = 4; // åŠ ç²—
            ctx.stroke();

            ctx.beginPath();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 10]);

            const W = CANVAS_RES;
            const H = CANVAS_RES;

            if (mode === 'sphere') {
                ctx.moveTo(0, 0); ctx.arc(0, H, H - 20, 1.5 * Math.PI, 0); 
            } else if (mode === 'cup') {
                const scale = W / 300; 
                ctx.moveTo(20*scale, 0); ctx.lineTo(20*scale, 100*scale); 
                ctx.bezierCurveTo(20*scale, 180*scale, 100*scale, 180*scale, 0, 180*scale); 
                ctx.moveTo(0, 180*scale); ctx.lineTo(0, 260*scale); ctx.lineTo(60*scale, 280*scale);
            } else if (mode === 'vase') {
                const scale = W / 300;
                ctx.moveTo(30*scale, 0); ctx.lineTo(20*scale, 40*scale); 
                ctx.bezierCurveTo(80*scale, 80*scale, 80*scale, 200*scale, 40*scale, 280*scale); 
                ctx.lineTo(0, 280*scale);
            }
            ctx.stroke();
            ctx.restore();
        }

        function drawSingleStroke(points, color, alpha) {
            if (points.length < 2) return;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = color;
            ctx.lineWidth = 6; // é«˜åˆ†å±ä¸‹åŠ ç²—çº¿æ¡
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }

        function smoothPoints(points) {
            if (points.length < 3) return points;
            const vec2Points = points.map(p => new THREE.Vector2(p.x, p.y));
            const curve = new THREE.SplineCurve(vec2Points);
            const smoothedVec2 = curve.getPoints(Math.max(50, points.length * 2));
            return smoothedVec2.map(v => ({ x: v.x, y: v.y }));
        }

        function update3DScene() {
            while(objectGroup.children.length > 0){ 
                const child = objectGroup.children[0];
                child.geometry.dispose();
                if (child.material) child.material.dispose();
                objectGroup.remove(child); 
            }

            strokes.forEach((stroke, index) => {
                const geometry = createLatheGeometry(stroke.points);
                if (geometry) {
                    const material = createMaterial(stroke.config);
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.name = "Lathe_" + stroke.config.type;
                    strokes[index].meshUUID = mesh.uuid;
                    objectGroup.add(mesh);
                }
            });
        }

        function createMaterial(config) {
            const params = {
                color: config.color,
                side: THREE.DoubleSide,
                flatShading: false,
                transparent: config.opacity < 1.0, 
                opacity: config.opacity
            };

            switch (config.type) {
                case 'glass':
                    return new THREE.MeshPhysicalMaterial({
                        ...params, metalness: 0.1, roughness: 0.05,
                        transmission: 0.9, thickness: 1.0, ior: 1.5,
                        clearcoat: 1.0, transparent: true 
                    });
                case 'metal':
                    return new THREE.MeshStandardMaterial({
                        ...params, metalness: 1.0, roughness: 0.25
                    });
                case 'glossy': 
                    return new THREE.MeshPhysicalMaterial({
                        ...params, metalness: 0.1, roughness: 0.1, clearcoat: 1.0
                    });
                case 'glow': 
                    return new THREE.MeshStandardMaterial({
                        ...params, emissive: config.color, emissiveIntensity: 2.0, toneMapped: false
                    });
                case 'frosted':
                    return new THREE.MeshPhysicalMaterial({
                        ...params, metalness: 0.1, roughness: 0.6,
                        transmission: 0.8, thickness: 1.5, transparent: true
                    });
                case 'standard':
                default:
                    return new THREE.MeshStandardMaterial({
                        ...params, roughness: 0.5, metalness: 0.1
                    });
            }
        }

        function createLatheGeometry(points2D) {
            if (points2D.length < 2) return null;
            const threePoints = [];
            const H = CANVAS_RES;
            // å½’ä¸€åŒ–åæ ‡è®¡ç®—
            for (let i = 0; i < points2D.length; i++) {
                const p = points2D[i];
                // åŠå¾„ 0~20
                const radius = (p.x / H) * 20; 
                // é«˜åº¦ 15~-15
                const height = ((H - p.y) / H) * 30 - 15;
                threePoints.push(new THREE.Vector2(Math.max(0, radius), height));
            }
            return new THREE.LatheGeometry(threePoints, 64);
        }

        function exportToOBJ() {
            if (objectGroup.children.length === 0) {
                alert("åœºæ™¯æ˜¯ç©ºçš„ï¼");
                return;
            }
            const exporter = new OBJExporter();
            const result = exporter.parse(objectGroup);
            const blob = new Blob([result], { type: 'text/plain' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'artist_lathe_model.obj';
            link.click();
        }

        function initThreeJS() {
            const container = document.getElementById('three-container');

            scene = new THREE.Scene();
            objectGroup = new THREE.Group(); 
            scene.add(objectGroup);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(25, 20, 40); 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            container.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
            mainLight.position.set(10, 20, 20);
            mainLight.castShadow = true;
            scene.add(mainLight);
            
            const blueLight = new THREE.PointLight(0x4facfe, 3.0);
            blueLight.position.set(-20, 10, -10);
            scene.add(blueLight);
            
            const orangeLight = new THREE.PointLight(0xffaa00, 2.0);
            orangeLight.position.set(20, -10, 10);
            scene.add(orangeLight);

            const gridHelper = new THREE.GridHelper(40, 40, 0x333333, 0x111111);
            gridHelper.position.y = -15; 
            scene.add(gridHelper);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true; 
            controls.autoRotateSpeed = 1.0;
            controls.addEventListener('start', () => { controls.autoRotate = false; });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                if(selectionBox) selectionBox.update();
                renderer.render(scene, camera);
            }
            animate();
        }

    </script>
</body>
</html>